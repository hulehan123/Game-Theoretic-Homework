#################################################
# (C) 状态转移概率: 结合不确定检测率
#################################################

from config import *

def transition_prob(w, a1, a2, pD):
    """
    给定当前状态 w, 入侵者动作 a1, IDS动作 a2, 以及检测率 pD(在 [p_min, p_max]),
    返回一个字典 { 下一个状态w': 概率 }.
    
    论文(20)式和(21)式中描述了:
       - w->w+1: 新节点被攻陷(attack成功)
       - w->w-1: 被攻陷节点被恢复(recover)
       - w->w  : 也可能停留原状态(或者其中之一概率为0)
    边界: w=0时无法再-1, w=W时无法再+1.
    """
    # 这里是一个示例, 你可以直接把(20),(21)式的公式实现进去。
    # 例如论文中写到 p^(s^1,s^2) (w->w+1) = 1 - p̂; p^(s^1,s^2) (w->w-1) = p̂ ...
    # 并让 p̂ 跟 pD、a1,a2 挂钩。

    # 先写一个简单版本:
    p_succ = 0.5  # 攻击者成功的基本概率
    if a1 == 1:
        p_succ += 0.3   # 高攻击 => 成功率上升
    if a2 == 1:
        p_succ -= 0.2   # 高扫描 => 攻击成功率下降

    # 考虑检测率 pD: 若 pD 高, 攻击者成功率进一步下降
    p_succ -= (pD - 0.5)*0.5
    p_succ = max(min(p_succ, 1.0), 0.0)

    # 下面构造概率dict
    probs = {}
    if w == 0:
        # 无法 -1
        # 假设 w->w+1 的概率 = p_succ
        # 剩余 (1 - p_succ) 不变(留在0)
        probs[w+1] = p_succ
        probs[w] = 1.0 - p_succ
    elif w == W:
        # 无法 +1
        # 假设 w->w-1 的概率 = (1 - p_succ)
        # 剩余 p_succ 留在W
        probs[w-1] = (1.0 - p_succ)
        probs[w] = p_succ
    else:
        # 一般情况
        # 可让 w->w+1 = p_succ,
        # w->w-1 = (1-p_succ)*0.5, w->w = (1-p_succ)*0.5
        # 只是个示例，可自由改成(21)式那种 w->w+1 = (W - w)/W * (1 - p̂), ...
        probs[w+1] = p_succ
        probs[w-1] = (1.0 - p_succ)*0.5
        probs[w] = (1.0 - p_succ)*0.5

    return probs
